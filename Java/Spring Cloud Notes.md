# Spring Cloud Notes

---

## 一、什么是微服务？优缺点？

> ​	==单个轻量级服务==一般为一个单独微服务，微服务讲究的是==专注某个功能的实现==，比如登录系统只专注于用户登录方面功能的实现，讲究的是==职责单一，开箱即用，可以独立运行==。微服务架构系统是一个分布式的系统，按照业务进行划分服务单元模块，解决单个系统的不足，满足越来越复杂的业务需求。

> **优点**：==低耦合，聚焦单一业务功能，无关开发语言==，团队规模降低。在开发中，不需要了解多有业务，只专注于当前功能，便利集中，功能小而精。微服务一个功能受损，对其他功能影响并不是太大，可以快速定位问题。微服务只专注于当前业务逻辑代码，不会和 html、css 或其他界面进行混合。可以灵活搭配技术，独立性比较舒服。
>
> **缺点**：随==着服务数量增加，管理复杂，部署复杂，服务器需要增多，服务通信和调用压力增大==，运维工程师压力增大，人力资源增多，系统依赖增强，数据一致性，性能监控。

## 二、euraka的特点

1. **提供完成的服务注册和服务发现实现**：首先是提供了==完整的服务注册和服务发现实现==。
2. **与SpirngCloud无缝集成**：Spring Cloud还有一套非常完善的开源代码来整合Eureka，所以使用起来非常方便。Eureka还支持在我们应用==自身的容器中启动==，也就是说我们的应用启动完之后，既充当了Eureka的角色，同时也是服务的提供者。这样就极大的提高了服务的==可用性==。
3. **服务续约**：在注册服务完成以后，服务提供者会==维持一个心跳==(每30秒定时向EurekaService发起请求)， ==告诉EurekaService 我还活着==，这个我们称为服务的续约(renew)。
4. **剔除**：有些时候，我们的服务提供方并==不一定会正常下线==，可能因为内存溢出，网络故障等原因导致服务无法正常工作，EurekeService需要将这样的服务剔服务列表。因为他会开启一个定时任务，==每隔60秒对所有失效的服务(超过90秒未响应)进行剔除==。
5. **自我保护机制**：当一个服务==未按时进行心跳续约==时， 在生产环境下，因为网络延迟等原因，此时就把服务剔除列表并不妥当，因为服务可能没有宕机，Eureka就会把==当前实例的注册信息保护起来==，不予剔除，生产环境下很有效，保证了系统的高可用。

##### 工作原理：

   **Eureka** : 就是服务注册中心(可以是一个集群), 对外暴露自己的地址

   **提供者**：启动后向Eureka注册自己的信息(地址,提供服务)

   **消费者**：向Eureka订阅服务,Eureka会将对应服务的所有提供者地址列表发送消费者,并且定期更新

   **心跳(续约)**：提供者定期通过http方式向Eureka刷新自己的状态

## 三、什么是Ribbon？

> Ribbon是Netflix发布的开源项目，主要功能是提==供客户端的软件负载均衡算法==，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供==一系列完善的配置项如连接超时，重试==等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon==实现自定义的负载均衡算法==。

**负载均衡有好几种实现策略**：

1. 随机 (Random)
2. 轮询 (RoundRobin)
3. 一致性哈希 (ConsistentHash)
4. 哈希 (Hash)
5. 加权（Weighted）

**原理**：

> ribbon是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，比如有==添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表==等等。

## 四、什么是熔断？什么是服务降级？

> ​	服务熔断的作用类似于我们家用的保险丝，当==某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用==。

> ​	服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部==暂时舍弃对一些非核心的接口和数据的请求==，而直接返回一个提前准备好的==fallback==（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了==整个系统的稳定性和可用性==。

## 五、Hystrix的原理及使用场景

##### 断路器机制：

> ​	断路器很好理解, 当==Hystrix Command请求后端服务失败数量超过一定比例(默认50%)，断路器会切换到开路状态(Open)==。这时所有请求会直接失败而不会发送到后端服务。断路器保持在开路状态一段时间后(默认5秒)，自动切换到半开路状态(HALF-OPEN)。这时会判断下一次请求的返回情况，如果请求成功，断路器切回闭路状态(CLOSED)。否则重新切换到开路状态(OPEN)。
>
> ​	Hystrix的断路器就像我们家庭电路中的保险丝，一旦后端服务不可用，断路器会直接切断请求链，避免发送大量无效请求影响系统吞吐量，并且==断路器有自我检测并恢复的能力==。

##### Fallback：

> ​	Fallback相当于是==降级操作==。对于查询操作，我们可以实现一个fallback方法，当请求后端服务出现异常的时候，可以使用fallback方法返回的值。fallback方法的返回值一般是设置的默认值或者来自缓存。

## 六、SpringCloud之服务网关Gateway

> ​	网关通常在项目中为了==简化前端的调用逻辑，同时也简化内部服务之间互相调用的复杂度==；具体作用就是==转发服务，接收并转发所有内外部的客户端调用==；其他常见的功能还有==权限认证，限流控制、熔断功能==等等。

## 七、Apollo动态加载机制

> ​	Apollo配置中心动态生效机制，是基于==Http长轮询请求和Spring扩展机制实现==的，在Spring容器启动过程中，Apollo通过自定义的BeanPostProcessor和BeanFactoryPostProcessor將参数中包含${…}占位符和@Value注解的Bean注册到Apollo框架中定义的注册表中。然后通过Http长轮询==不断的去获取服务端的配置信息==，==一旦配置发生变化，Apollo会根据变化的配置的Key找到对应的Bean，然后修改Bean的属性，从而实现了配置动态生效的特性==。
>
> 需要注意的是，Apollo在配置变化后，==只能修改Bean的属性，例如我们数据源的属性发生变化，新创建的Connection对象是没问题的，但是连接池中已经创建的Connection对象相关信息是不能动态修改的==，所以依然需要重启应用。



