# Java基础

-----

## 一、基础知识

#### 1.1、为什么重写equals还需要重写hashcode？

> **作用：**
>
> 1. hashCode和equals方法都是Object类中的方法。
>    1. ==不重写==：
>       1. hashcode：属于本地方法，返回的是对象的地址值。
>       2. equals：用来比较两个对象的地址值是否相等。（==）
>    2. ==重写==：
>       1. hashcode：返回的是根据对象的成员变量，计算出的一个整数。
>       2. equals：比较的是两个对象中成员信息是否相同。
> 2. hashcode和equals比较两个对象是否相等的区别
>    1. 两个对象通过equals比较是相等的，那么hashcode肯定相等，也就是equals是绝对可靠的。
>    2. 两个对象通过hashcode比较相等，但是equals比较不一定相等。
> 3. 通过hashcode和equals搭配使用比较对象是否相等，如何提高效率？
>    1. 对于一个对象中含有大量的成员信息，用equals比较会降低效率。可以先通过hashcode比较，不相等则两个对象一定不同，相同则再次通过equals比较。如：hashSet集合
>
> **结论**：
>
> ==如果仅仅重写了equals（），而没有重写hashCode()方法，会出现什么情况？==
>
> ​	字段属性值完全相同的两个对象因为hashCode不同，所以在hashmap中的table数组的下标不同，从而这两个对象就会同时存在于集合中，所以重写equals()就一定要重写hashCode()方法。
>
> 对于“为什么重写equals()就一定要重写hashCode()方法？”这个问题应该是有个前提，就是你需要用到HashMap,HashSet等Java集合。用不到哈希表的话，其实仅仅重写equals()方法也可以吧。而工作中的场景是常常用到Java集合，所以Java官方建议 重写equals()就一定要重写hashCode()方法。



---

## 二、集合

#### 2.1、HashMap的底层实现

> **优点**：是随机读取效率很高，原因数组是连续（随机访问性强，查找速度快）。
>
> **缺点**：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中要往后移的，且大小固定不易动态扩展。
>
> **特点**：
>
> 1. 允许key/value为null，但是key只能有一个null
> 2. 非线程安全，是可以序列化的
>
> 3. HashMap的底层主要是基于==数组和链表==实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储位置的。
> 4. JDK8之后，如果哈希表单向链表中元素超过8个，那么单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6个，会重新把红黑树变成单向链表数据结构。
>
> **map.put(k,v)实现原理**
>
> 首先将k,v封装到Node对象当中（节点）。
>
> 它的底层会调用K的hashCode()方法得出hash值。
>
> 通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。
>
> **map.get(k)实现原理**
>
> 第一步：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。
>
> 第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。重点理解如果这个位置上什么都没有，则返回null。如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。











